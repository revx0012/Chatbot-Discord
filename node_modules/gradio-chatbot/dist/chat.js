"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GradioChatBot = exports.generateHash = exports.spaces = void 0;
const weaigc_turndown_1 = __importDefault(require("weaigc-turndown"));
const debug_1 = __importDefault(require("debug"));
const assert_1 = __importDefault(require("assert"));
const client_1 = require("./client");
const spaces_json_1 = __importDefault(require("./spaces.json"));
exports.spaces = spaces_json_1.default;
const debug = (0, debug_1.default)('gradio-chatbot');
const generateHash = () => {
    return Math.random().toString(36).substring(2);
};
exports.generateHash = generateHash;
const turndownService = new weaigc_turndown_1.default({
    rules: {
        emphasis: {
            filter: ['br'],
            replacement: () => {
                return '\n';
            }
        }
    }
});
function resolveEndpoint(url) {
    debug('url', url);
    const uri = new URL(url);
    debug('resolve', uri.hostname);
    if (uri.hostname === 'modelscope.cn') {
        (0, assert_1.default)(/^\/studios\/([^/]+)\/([^/]+)/.test(uri.pathname), 'not a valid modelscope studio url');
        const scope = RegExp.$1;
        const name = RegExp.$2;
        return `https://modelscope.cn/api/v1/studio/${scope}/${name}/gradio`;
    }
    else if (/^https:\/\/huggingface\.co\/spaces\/([^/]+)\/([^/]+)/.test(url)) {
        return `${RegExp.$1}-${RegExp.$2}.hf.space`.toLowerCase().replace(/_/g, '-');
    }
    else {
        return uri.host;
    }
}
const traverseContent = (data) => {
    if (!Array.isArray(data)) {
        return data?.value || data;
    }
    return traverseContent(data.at(-1));
};
const findValidSubmitByType = (components, dependencies, type) => {
    const id = components.find(com => com.type === 'button' && com.props.value === 'Submit')?.id;
    let index = dependencies.findIndex(dep => dep.targets?.includes?.(id));
    return index === -1 ? dependencies.findIndex((dep = {}) => dep.inputs?.length
        && dep.outputs?.length
        && dep.backend_fn
        && dep.trigger === type) : index;
};
const findValidSubmitByButton = (components, dependencies) => {
    const id = components.find(com => com.type === 'button')?.id;
    if (!id)
        return -1;
    return dependencies.findIndex(dep => dep.inputs?.length > 0 && dep.targets?.includes?.(id));
};
class GradioChatBot {
    options;
    history = [];
    session_hash;
    instance_map;
    constructor(opts = '0') {
        if (typeof opts === 'string') {
            this.options = { url: opts };
        }
        else {
            this.options = opts;
        }
        (0, assert_1.default)(this.options.endpoint || this.options.url, 'endpoint and url must specify one of them');
        if (!isNaN(this.options.url)) {
            const index = parseInt(this.options.url, 10);
            (0, assert_1.default)(index < spaces_json_1.default.length, `The model index range is [0 - ${spaces_json_1.default.length - 1}].`);
            let config = spaces_json_1.default[index];
            if (typeof config === 'string') {
                config = { url: config };
            }
            Object.assign(this.options, config);
        }
        if (!this.options.endpoint) {
            this.options.endpoint = resolveEndpoint(this.options.url);
        }
        this.session_hash = this.options.session_hash || (0, exports.generateHash)();
        if (!this.options.historySize) {
            this.options.historySize = 10;
        }
        this.options.parseHtml = this.options.parseHtml !== false;
    }
    parseInputs = (fnIndex, config, skip_text = false) => {
        const { components, dependencies } = config;
        const submitFn = dependencies[fnIndex];
        const inputs = submitFn?.inputs.map(id => this.instance_map[id].props.value);
        debug('fnIndex', fnIndex);
        let textInputIndex = skip_text ? 0 : submitFn?.inputs.indexOf(submitFn?.targets?.[0]);
        if (textInputIndex < 0) {
            textInputIndex = submitFn?.inputs.findIndex((id) => components?.find((com) => id === com.id
                && (com.type === 'textbox' || com.example_input)));
        }
        (0, assert_1.default)(textInputIndex > -1, 'Cannot find the input box');
        debug('inputIndex', textInputIndex);
        return [inputs, textInputIndex];
    };
    html2Markdown(text) {
        text = this.options.parseHtml ? turndownService.turndown(text || '') : text;
        return text?.replace?.(/ï¿½/g, '').trim();
    }
    async reset() {
        this.history = [];
        this.instance_map = null;
        this.session_hash = (0, exports.generateHash)();
    }
    async chat(input, options) {
        (0, assert_1.default)(input, 'input can\'t be empty!');
        return new Promise(async (resolve, reject) => {
            try {
                let { endpoint, fnIndex, args = [], hf_token } = this.options;
                const app = await (0, client_1.client)(endpoint, { session_hash: this.session_hash, hf_token: hf_token, normalise_files: true });
                const { components, dependencies } = app.config;
                let instance_map = this.instance_map;
                if (!instance_map) {
                    instance_map = components.reduce((acc, next) => {
                        acc[next.id] = next;
                        return acc;
                    }, {});
                    this.instance_map = instance_map;
                }
                fnIndex = fnIndex ?? findValidSubmitByType(components, dependencies, 'submit');
                if (fnIndex < 0) {
                    fnIndex = Math.max(findValidSubmitByButton(components, dependencies), findValidSubmitByType(components, dependencies, 'click'));
                }
                (0, assert_1.default)(fnIndex !== -1, 'Failed to parse this space, you may need to specify the fnIndex manually!');
                let [inps, inpIndex] = this.parseInputs(fnIndex, app.config);
                if (!args?.length) {
                    args = inps;
                }
                let inputIndex = this.options.inputIndex ?? inpIndex;
                if (inputIndex > -1) {
                    args[inputIndex] = input;
                }
                debug('args', fnIndex, JSON.stringify(args));
                const fn_status = [];
                let _error_id = -1;
                let messages = [];
                const MESSAGE_QUOTE_RE = /^'([^]+)'$/;
                let submit_map = new Map();
                const handle_update = (data, fn_index) => {
                    const outputs = dependencies[fn_index].outputs;
                    data?.forEach((value, i) => {
                        const output = instance_map[outputs[i]];
                        output.props.value_is_output = true;
                        if (typeof value === "object" &&
                            value !== null &&
                            value.__type__ === "update") {
                            for (const [update_key, update_value] of Object.entries(value)) {
                                if (update_key === "__type__") {
                                    continue;
                                }
                                else {
                                    output.props[update_key] = update_value;
                                }
                            }
                        }
                        else {
                            output.props.value = value;
                            if (process.env.DEBUG) {
                                debug('value', output.type, JSON.stringify(value));
                            }
                            if (output.type === 'chatbot' && value) {
                                this.history = value.slice(-this.options.historySize);
                                output.props.value = this.history;
                                const message = value?.at(-1)?.at(-1);
                                options?.onMessage?.(this.html2Markdown(message));
                            }
                        }
                    });
                };
                const trigger_api_call = async (dep_index, data = null, event_data = null) => {
                    let dep = dependencies[dep_index];
                    const current_status = fn_status[dep_index];
                    messages = messages.filter(({ fn_index }) => fn_index !== dep_index);
                    if (dep.cancels) {
                        await Promise.all(dep.cancels.map(async (fn_index) => {
                            const submission = submit_map.get(fn_index);
                            submission?.cancel();
                            return submission;
                        }));
                    }
                    if (current_status === "pending" || current_status === "generating") {
                        return;
                    }
                    let payload = {
                        fn_index: dep_index,
                        data: data || dep.inputs.map((id) => instance_map[id].props.value),
                        event_data: dep.collects_event_data ? event_data : null
                    };
                    const make_prediction = () => {
                        const submission = app.submit(payload.fn_index, payload.data, payload.event_data)
                            .on("data", ({ data, fn_index }) => {
                            handle_update(data, fn_index);
                        })
                            .on("status", ({ fn_index, ...status }) => {
                            fn_status[fn_index] = status.stage;
                            debug('status', status.stage);
                            if (status.stage === "complete") {
                                let end = true;
                                dependencies.map(async (dep, i) => {
                                    if (dep.trigger_after === fn_index) {
                                        end = false;
                                        trigger_api_call(i);
                                    }
                                });
                                submission.destroy();
                                if (end) {
                                    const message = this.history?.at(-1)?.at(-1);
                                    resolve(this.html2Markdown(message));
                                }
                            }
                            if (status.stage === "error") {
                                if (status.message) {
                                    const _message = status.message.replace(MESSAGE_QUOTE_RE, (_, b) => b);
                                    messages = [
                                        {
                                            type: "error",
                                            message: _message,
                                            id: ++_error_id,
                                            fn_index
                                        },
                                        ...messages
                                    ];
                                }
                                dependencies.map(async (dep, i) => {
                                    if (dep.trigger_after === fn_index &&
                                        !dep.trigger_only_on_success) {
                                        trigger_api_call(i);
                                    }
                                });
                                options?.onError?.(status.message || 'error');
                                reject(status.message || 'error');
                                submission.destroy();
                            }
                        });
                        submit_map.set(dep_index, submission);
                    };
                    if (dep.frontend_fn) {
                        dep
                            .frontend_fn(payload.data.concat(dep.outputs.map((id) => instance_map[id].props.value)))
                            .then((v) => {
                            if (dep.backend_fn) {
                                payload.data = v;
                                make_prediction();
                            }
                            else {
                                handle_update(v, dep_index);
                            }
                        });
                    }
                    else {
                        if (dep.backend_fn) {
                            make_prediction();
                        }
                    }
                };
                trigger_api_call(fnIndex, args);
            }
            catch (e) {
                reject(e);
            }
        });
    }
    ;
}
exports.GradioChatBot = GradioChatBot;
